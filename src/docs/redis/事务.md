---
title: 事务
category: [数据库]
tag: [NoSQL, Redis]
abbrlink: 1a1c90d1
date: 2022-04-06 22:33:14
article: false
order: 5
---

# 事务

可以一次执行多个命令，本质是一组命令的集合。一个事务中的所有命令都会序列化，**按顺序地串行化执行执行而不会被其它命令插入，不许加塞**。

**一个队列中，一次性、顺序性、排他性的执行一系列命令**

## 命令

下表列出了 redis 事务的相关命令：

|序号|命令及描述|
| :---| :----------------------------------------------------------------------------------------------|
|1|`DISCARD` 取消事务，放弃执行事务块内的所有命令。|
|2|`EXEC` 执行所有事务块内的命令。|
|3|`MULTI` 标记一个事务块的开始。|
|4|`UNWATCH` 取消 WATCH 命令对所有 key 的监视。|
|5|`WATCH key [key ...]` 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。|

## 案例

> 正常执行事务

```shell
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> set k1 1
QUEUED
127.0.0.1:6379> set k2 2
QUEUED
127.0.0.1:6379> get k2
QUEUED
127.0.0.1:6379> set k3 3
QUEUED
127.0.0.1:6379> EXEC
1) OK
2) OK
3) "2"
4) OK
```

> 放弃事务

```shell
127.0.0.1:6379> get k1
"1"
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> set k1 111
QUEUED
127.0.0.1:6379> DISCARD
OK
127.0.0.1:6379> get k1
"1"
```

> 全体连坐：属于在添加队列阶段就出错，因此整个事务直接失败

```shell
127.0.0.1:6379> FLUSHALL
OK
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> set k1 1
QUEUED
127.0.0.1:6379> set k2 2
QUEUED
127.0.0.1:6379> sets k3 3
(error) ERR unknown command 'sets'
127.0.0.1:6379> EXEC
(error) EXECABORT Transaction discarded because of previous errors.
127.0.0.1:6379> keys *
(empty list or set)
```

> 冤头债主：属于任务队列添加成功，只是执行时有一个命令有问题，不影响其他命令执行

```shell
127.0.0.1:6379> FLUSHALL
OK
127.0.0.1:6379> set k1 a1
OK
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> INCR k1
QUEUED
127.0.0.1:6379> set k2 2
QUEUED
127.0.0.1:6379> set k3 3
QUEUED
127.0.0.1:6379> EXEC
1) (error) ERR value is not an integer or out of range
2) OK
3) OK
127.0.0.1:6379> get k2
"2"
```

> watch监控

悲观锁（Pessimistic Lock），顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁这样别人想拿这个数据就会block直到它拿到锁，传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁

乐观锁（Optimistic Lock），顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制，乐观锁适用于多读的应用类型，这样可以提高吞吐量。乐观锁策略：提交版本必领大于记录当前版本才能执行更新

1、商家账户0元，消费者账户100元，在消费者支付之前对账户进行监控，支付时，没有其他客户端操作，执行正常

```shell
127.0.0.1:6379> set business 0
OK
127.0.0.1:6379> set consumer 100
OK
127.0.0.1:6379> WATCH consumer
OK
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> INCRBY business 20
QUEUED
127.0.0.1:6379> DECRBY consumer 20
QUEUED
127.0.0.1:6379> EXEC
1) (integer) 20
2) (integer) 80
```

2、商家账户20元，消费者账户80元，在消费者支付之前对账户进行监控，支付时，有其他客户端操作，执行错误

|客户端1|客户端2|
| --------------------------------------------------------------------------------------------------------------------------------| ---------------------------------------------------------------------------------------------------------------------------------|
|127.0.0.1:6379> WATCH consumer<br />OK||
||127.0.0.1:6379> keys *<br />1) "consumer"<br />2) "business"<br />127.0.0.1:6379> INCRBY consumer 800<br />(integer) 880<br />127.0.0.1:6379> get consumer<br />"880"|
|127.0.0.1:6379> MULTI<br />OK<br />127.0.0.1:6379> INCRBY business 20<br />QUEUED<br />127.0.0.1:6379> DECRBY consumer 20<br />QUEUED<br />127.0.0.1:6379> EXEC<br />(nil)||
|127.0.0.1:6379> get business<br />"20"<br />127.0.0.1:6379> get consumer<br />"880"||

3、商家账户20元，消费者账户880元，在消费者支付之前对账户进行监控，支付时，有其他客户端操作，先取消监控，再重新监控

|客户端1|客户端2|
| --------------------------------------------------------------------------------| ----------------------------------------------|
|127.0.0.1:6379> WATCH business consumer<br />OK||
||127.0.0.1:6379> INCRBY consumer 8<br />(integer) 888|
|127.0.0.1:6379> UNWATCH<br />OK<br />127.0.0.1:6379> WATCH business consumer<br />OK||
|127.0.0.1:6379> MULTI<br />OK||
|127.0.0.1:6379> INCRBY business 20<br />QUEUED<br />127.0.0.1:6379> DECRBY consumer 20<br />QUEUED||
|127.0.0.1:6379> EXEC<br />1) (integer) 40<br />2) (integer) 868||

Watch指令，类似乐观锁，事务提交时，如果Key的值已被别的客户端改变，比如某个list已被别的客户端push/pop过了，整个事务队列都不会被执行

通过WATCH命令在事务执行之前监控了多个Keys，倘若在WATCH之后有任何Key的值发生了变化，EXEC命令执行的事务都将被放弃，同时返回Nullmulti-bulk应答以通知调用者事务执行失败

## 小结

> 阶段

开启：以MULTI开始一个事务

入队：将多个命令入队到事务中，接到这些命令并不会立即执行，而是放到等待执行的事务队列里面

执行：由EXEC命令触发事务

> 特性

**单独的隔离操作**：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。

**没有隔离级别的概念**：队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行，也就不存在**"事务内的查询要看到事务里的更新，在事务外查询不能看到"**这个让人万分头痛的问题

**不保证原子性**：redis同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚。
