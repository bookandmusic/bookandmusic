---
title: 锁机制
category: [数据库]
tag: [MySQL, SQL, 事务, 锁]
date: 2022-03-21 21:24:32
article: false
order: 4
---

# 锁机制

# 事务

> 事务概念及四大特性

　　事务是由一组`SQL`语句组成的逻辑处理单元，事务具有以下4个属性，通常简称为事务的ACID属性。

- 原子性(Atomicity):事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。
- 一致性(Consistent):在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改以保持数据的完整性；事务结束时，所有的内部数据结构(如B树索引或双向链表)也都必须是正确的。
- 隔离性(Isolation):数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的"独立"环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。
- 持久性(Durable):事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。

> 并发事务处理带来的问题

　　**更新丢失(Lost Update)**

　　当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题-一最后的更新覆盖了由其他事务所做的更新。

　　例如，两个程序员修改同一python文件。每程序员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。最后保存其更改副本的编辑人员覆盖前一个程序员所做的更改。

　　如果在一个程序员完成并提交事务之前，另一个程序员不能访问同一文件，则可避免此问题。

　　**脏读(Dirty Reads)**

　　一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些"脏"数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做"脏读"。

　　一句话:事务A读取到了事务B**已修改但尚未提交**的的数据，还在这个数据基础上做了操作。此时，如果B事务回滚，A读取的数据无效，不符合一致性要求。

　　**不可重复读(Non-Repeatable Reads)**

　　一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫做"不可重复读"。

　　一句话:事务A读取到了事务B**已经提交**的修改数据，不符合隔离性

　　**幻读(Phantom Reads)**

　　一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为"幻读一句话:事务A读取到了事务B体提交的新增数据，不符合隔离性。

　　多说一句:幻读和脏读有点类似，脏读是事务B里面修改了数据，幻读是事务B里面新增了数据。

> 事务隔离级别

　　"脏读"、"不可重复读"和"幻读"，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决。

|读数据一致性及允许的并发副作用隔离级别|隔离級别|脏读|不可重复读|幻读|
| --------------------------------------| ----------------------------------------| ----| ----------| ----|
|未提交读(Read uncommitted)|最低级别，只能保证不读取物理上损坏的数据|是|是|是|
|已提交读(Read committed)|语句级|否|是|是|
|可重复读(Repeatable read)|事务级|否|否|是|
|可序列化(Serializable)|最高级别，事务级|否|否|否|

　　数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是使事务在一定程度上"串行化"进行，这显然与"并发"是矛盾的。同时，不同的应用对读一致性和事务隔离程度的要求也是不同的，比如许多应用对"不可重复读"和"幻读"并不敏感，可能更关心数据并发访问的能力。

　　查看当前数据库的事务隔离级别:`show variables like'tx_isolation';`

# MySQL锁

## 概述

　　锁是计算机协调多个进程或线程并发访问某一资源的机制。
在数据库中，除传统的计算资源(如CPU、RAM、I/O等)的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。

　　从对数据操作的类型分:

　　读锁(共享锁):针对同一份数据，多个读操作可以同时进行而不会互相影响。

　　写锁(排它锁):当前写操作没有完成前，它会阻断其他写锁和读锁。

　　从对数据操作的粒度分:表锁、行锁、页锁

## 表锁

　　表锁(偏读):偏向MyISAM存储引擎，开销小，加锁快；无死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。

```shell
# 手动增加表锁
lock table 名字 read(write),表名字2 read(write),其它;
# 查看表上加过的锁
show open tables;
# 解锁
unlock tables;
```

### 案例

> 对mylock表加read锁(MyISAM存储引擎的读阻塞读例子)

|session1|session2|
| ---------------------------------------------| -------------------------------------|
|获得表mylock的READ锁定: `lock table mylock read;`|连接终端|
|当前session可以查询该表记录:`select * from mylock;`|其他session也可以查询该表的记录|
|当前session不能查询其它没有锁定的表，查询报错|其他session可以查询或者更新未锁定的表|
|当前session中插入或者更新锁定的表都会提示错误|其他session插入或者更新锁定表**会一直等待**获得锁|
|释放锁:`unlock tables;`|Session2获得锁，插入遇作完成|

> 对mylock表加write锁(MyISAM存储引擎的写阻塞读例子)

|session1|session2|
| -------------------------------------------------| ----------------------------------------------------------------------------------------------------------------------------------------------------------|
|获得表mylock的READ锁定: `lock table mylock write;`|待Session1开启写锁后，session2再连接终端|
|当前session对锁定表的查询+更新+插入操作都可以执行|其他session对锁定表的查询被阻塞，需要等待锁被释放；备注:如果可以，语换成不同的id来进行测试，因为mysgl聪明有缓存，第2次的条件会从从缓存取得，影响锁效果演示|
|释放锁:`unlock tables;`|Session2获得锁，查询返回|

### 表锁分析

　　查看哪些表被加锁了

```mysql
show open tables;
```

　　如何分析表锁定

```mysql
mysql> show status like "table%";
+----------------------------+-------+
| Variable_name              | Value |
+----------------------------+-------+
| Table_locks_immediate      | 1     |
| Table_locks_waited         | 0     |
| Table_open_cache_hits      | 288   |
| Table_open_cache_misses    | 26    |
| Table_open_cache_overflows | 0     |
+----------------------------+-------+
5 rows in set (0.00 sec)
```

　　`table_locks_waited`和`table_locks_immediate`两个状态变量记录MySQL内部表级锁定的情况，两个变量说明如下:

　　`Table_locks_immediate`:产生表级锁定的次数，表示可以立即获取锁的查询次数，每立即获取锁值加1；

　　`Table_locks_waited`:出现表级锁定争用而发生等待的次数(不能立即获取锁的次数，每等待一次锁值加1)，此值高则说明存在着较严重的表级锁争用情况；

　　此外，MyISAM的读写锁调度是写优先，这也是MyISAM不适合做写为主表的引擎。因为写锁后，其他线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞。

### 小结

> 读锁 VS 写锁

　　MyISAM在执行查询语句(SELECT)前，会自动给涉及的所有表加读锁，在执行增删改操作前，会自动给涉及的表加写锁。
MySQL的表级锁有两种模式:表共享读锁(Table Read Lock)、表独占写锁(Table Write Lock)

|锁类型|可否兼容|读锁|写锁|
| ------| --------| ----| ----|
|读锁|是|是|否|
|写锁|是|否|否|

　　结论:结合上表，所以对MyISAM表进行操作，会有以下情况:

　　1、对MyISAM表的读操作(加读锁)，不会阻塞其他进程对同一表的读请求，但会阻塞对同一表的写请求。只有当读锁释放后，才会执行其它进程的写操作。

　　2、对MyISAM表的写操作(加写锁)，会阻塞其他进程对同一表的读和写操作，只有当写锁释放后，才会执行其它进程的读写操作。

　　简而言之，就是读锁会阻塞写，但是不会堵塞读。而写锁则会把读和写都堵塞。

## 行锁

　　行锁(偏写):偏向InnoDB存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。

　　InnoDB与MyISAM的最大不同有两点:一是支持事务(TRANSACTION)；二是采用了行级锁

### 案例

> 建表

```mysql
DROP TABLE IF EXISTS employee;
CREATE TABLE IF NOT EXISTS employee (
    id INT PRIMARY KEY auto_increment,
    name VARCHAR(40),
    money INT
)ENGINE INNODB;
```

> 插入数据

```mysql
INSERT INTO employee(name, money) VALUES('1001', 10000);
INSERT INTO employee(name, money) VALUES('1002', 10000);
```

> 没有索引,插入不同行数据

|session1|session2|
| -----------------------| -------------------------|
|开启行锁: `set autocommit=0;`|开启行锁: `set autocommit=0;`|
|更新数据，但是没有提交:`UPDATE employee SET money = money + 10000 WHERE name = '1001';`|session2被阻塞，只能等待:`UPDATE employee SET money = money + 5000 WHERE name = '1002';`|
|提交更新:`commit;`|解除阻塞，更新正常进行|
||提交更新:`commit;`|

　　两边结果相同，且正确。

　　但问题是，左侧操作的是 `name = '1001'` 记录而右侧操作的是 `name = '1002'` 记录，右侧还是被阻塞了，说明，左侧的更新操作锁住了全表！究其原因，是因为 name 字段上没有索引！

　　当 Where 查询条件中的字段没有索引时，更新操作会锁住全表！

> 有索引，插入不同行数据

```mysql
CREATE INDEX idx_name ON employee(name);
```

|session1|session2|
| -------------| -------------|
|开启行锁: `set autocommit=0;`|开启行锁: `set autocommit=0;`|
|正常更新数据:`UPDATE employee SET money = money + 10000 WHERE name = '1001';`|正常更新数据:`UPDATE employee SET money = money + 5000 WHERE name = '1002';`|
|提交更新:`commit;`|提交更新:`commit;`|

　　在有索引的情况下，更新不同的行，`InnoDB` 默认的行锁不会阻塞。

> 有索引，插入同行数据

```mysql
CREATE INDEX idx_name ON employee(name);
```

|session1|session2|
| -------------| -------------------------|
|开启行锁: `set autocommit=0;`|开启行锁: `set autocommit=0;`|
|正常更新数据:`UPDATE employee SET money = money + 10000 WHERE name = '1001';`|session2被阻塞，只能等待:`UPDATE employee SET money = money + 5000 WHERE name = '1002';`|
|提交更新:`commit;`|解除阻塞，更新正常进行|
||提交更新:`commit;`|

　　即使在有索引的情况下，更新相同的行，`InnoDB` 默认的行锁也会阻塞。

> 索引失效，插入不同行数据

|session1|session2|
| -------------| -------------------------|
|开启行锁: `set autocommit=0;`|开启行锁: `set autocommit=0;`|
|正常更新数据:`UPDATE employee SET money = money + 10000 WHERE name = 1001;`|session2被阻塞，只能等待:`UPDATE employee SET money = money + 5000 WHERE name = '1002';`|
|提交更新:`commit;`|解除阻塞，更新正常进行|
||提交更新:`commit;`|

　　Where 条件中的查询字段虽然有索引，但是索引失效时(本例子中是字符串没有加单引号)，InnoDB 默认的行锁更新操作变为表锁。

　　我们看到InnoDB默认的行锁可以使得操作不同行时不会产生相互影响、不会阻塞，从而很好的解决了多事务和并发的问题。但是，那得基于一个前提，即`Where`条件中使用上了索引；反之，如果没有使用上索引，则是全表扫描、全部阻塞。

> 间隙锁

|session1|session2|
| -------------| -------------------------|
|开启行锁: `set autocommit=0;`|开启行锁: `set autocommit=0;`|
|正常更新数据:`UPDATE employee SET money = money + 10000 WHERE name = 1001;`|session2被阻塞，只能等待:`INSERT INTO employee(id, name, money) VALUES(3, '1003', 10000);`|
|提交更新:`commit;`|解除阻塞，更新正常进行|
||提交更新:`commit;`|

　　当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做"间隙(GAP)"，InnoDB也会对这个"间隙"加锁，这种锁机制就是所谓的间隙锁(Next-Key锁)。
因为Query执行过程中通过过范围查找的话，他会锁定整个范围内所有的索引键值，即使这个键值并不存在。
间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无享的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害。

> 锁定特定行

```mysql
begin;  # 开启事务
select * from table_name where filed=value from update;  # 开启行锁
# 执行逻辑
commit;  # 提交事务
```

### 行锁分析

　　如何分析行锁定

```mysql
mysql> show status like 'innodb_row_lock%';
+-------------------------------+-------+
| Variable_name                 | Value |
+-------------------------------+-------+
| Innodb_row_lock_current_waits | 0     |
| Innodb_row_lock_time          | 88261 |
| Innodb_row_lock_time_avg      | 22065 |
| Innodb_row_lock_time_max      | 50000 |
| Innodb_row_lock_waits         | 4     |
+-------------------------------+-------+
5 rows in set (0.00 sec)
```

　　通过检查`InnoDB_row_lock`状态变量来分析系统上的行锁的争夺情况

　　对各个状态量的说明如下:
`Innodb_row_lock_current_waits`:当前正在等待锁定的数量；

　　`Innodb_row_lock_time`:从系统启动到现在锁定总时间长度；

　　`Innodb_row_lock_time_avg`:每次等待所花平均时间；

　　`Innodb_row_lock_time_max`:从系统启动到现在等待最常的一次所花的时间；

　　`Innodb_row_lock_waits`:系统启动后到现在总共等待的次数；

　　对于这5个状态变量，比较重要的主要是:
`Innodb_row_lock_time_avg`(等待平均时长)

　　`Innodb_row_lock_waits`(等待总次数)

　　`Innodb_row_lock_time`(等待总时长)

　　尤其是当等待次数很高，而且每次等待时长也不小的时候，我们就需要使用`show profile`，分析系统中为什么会有如此多的等待，然后根据分析结果着手指定优化计划。

### 小结

　　Innodb存储引警由于实现了行级锁定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更高一些，但是在整体并发处理能力方面要远远优于MyISAM的表级锁定的。当系统并发量较高的时候，Innodb的整体性能和MyISAM相比就会有比较明显的优势了。
但是，Innodb的行级锁定同样也有其脆弱的一面，当我们使用不当的时候，可能会让Innodb的整体性能表现不仅不能比MylSAM高，甚至可能会更差。

　　优化建议:

　　尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁。

　　合理设计索引，尽量缩小锁的范围

　　尽可能较少检索条件，避免间隙锁

　　尽量控制事务大小，减少锁定资源量和时间长度

　　尽可能低级别事务隔离

## 页锁

　　开销和加锁时间界于表锁和行锁之间；

　　会出现死锁；

　　锁定粒度界于表锁和行锁之间，并发度一般。
