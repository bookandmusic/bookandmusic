---
title: python垃圾回收机制
category: Python
date: 2024-07-08T01:50:53.000Z
updated: 2024-07-09T07:45:15.000Z
---
简单分析一下python中的垃圾回收机制，主要从三方面阐述：引用计数、标记清除、分代回收。

## 引用计数

> 引用计数是什么？

引用计数是编程语言中的一种内存管理技术；将资源(可以是对象、内存或磁盘空间等)的引用次数保存起来

**引用计数为零时，资源将被释放。**

> 如何使引用计数减少？

`del`语句会删除对象的一个引用，这会导致该引用指向的对象的引用计数减1

==注意==：任何调试或追踪程序会给对象增加一个额外引用，这会推迟该对象的回收时间

> 引用计数会导致什么问题？

由于两个或以上对象互相引用时，彼此引用计数不为0, 造成**循环引用**而无法回收。

```python
In [1]: a = [1]

In [2]: b = [2]

In [3]: a.append(b)

In [4]: b.append(a)

In [5]: a
Out[5]: [1, [2, [...]]]

In [6]: b
Out[6]: [2, [1, [...]]]
```

> 如何查看引用计数？

```python
In [7]: import sys

In [8]: sys.getrefcount(a)
Out[8]: 15

In [9]: sys.getrefcount(b)
Out[9]: 15
```

## 标记清除

Python引入了其它的垃圾回收机制来弥补引用计数的缺陷："标记-清除"

『标记清除（Mark—Sweep）』算法是一种基于追踪回收（tracing GC）技术实现的垃圾回收算法。它分为两个阶段：第一阶段是标记阶段，GC会把所有的『活动对象』打上标记，第二阶段是把那些没有标记的对象『非活动对象』进行回收。那么GC又是如何判断哪些是活动对象哪些是非活动对象的呢？

对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。根对象就是全局变量、调用栈、寄存器。

​![202407051025597](assets/net-img-202407051025597-20240709154734-1yn7soh.svg)​

> 在上图中，我们把小黑圈视为全局变量，也就是把它作为`root object`，从小黑圈出发，对象1可直达，那么它将被标记，对象2、3可间接到达也会被标记，而4和5不可达，那么1、2、3就是活动对象，4和5是非活动对象会被GC回收。

垃圾标记时（也就是检测循环引用时），先将集合中对象的引用计数复制一份副本(以免在操作过程中破坏真实的引用计数值)

这个计数副本的唯一作用是寻找`root object`集合(该集合中的对象是不能被回收的)。

当成功寻找到`root object`集合之后。首先将如今的内存链表一分为二，一条链表中维护`root object`集合，称为`root`链表；而另外一条链表中维护剩下的对象，称`unreachable`链表。

之所以要剖成两个链表，是基于这种一种考虑：如今的`unreachable`可能存在被`root`链表中的对象直接或间接引用的对象，这些对象是不能被回收的。一旦在标记的过程中，发现这种对象，就将其从`unreachable`链表中移到`root`链表中。

当标记完毕后，`unreachable`链表中剩下的全部对象就是名副事实上的垃圾对象了，接下来的垃圾回收仅仅需限制在`unreachable`链表中就可以。

标记清除算法作为Python的辅助垃圾收集技术主要处理的是一些容器对象，比如`list`、`dict`、`tuple`，`instance`等，因为对于字符串、数值对象是不可能造成循环引用问题。Python使用一个双向链表将这些容器对象组织起来。不过，这种简单粗暴的标记清除算法也有明显的缺点：清除非活动的对象前它必须顺序扫描整个堆内存，哪怕只剩下小部分活动对象也要扫描所有对象。

## 分代回收

一系列的研究表明：不管使用何种语言开发。不管开发的是何种类型，何种规模的程序，都存在这样一点同样之处。即：**一定比例的内存块的生存周期都比較短，一般是几百万条机器指令的时间。而剩下的内存块,其生存周期比较长，甚至会从程序开始一直持续到程序结束**。

从前面“标记-清除”这种垃圾收集机制来看。这种垃圾收集机制所带来的额外操作，实际上与系统中总的内存块的数量是相关的。当须要回收的内存块越多时，垃圾检测带来的额外操作就越多；反之，垃圾回收带来的额外操作就越少。

将系统中的全部内存块依据其存活时间划分为不同的集合，每个集合就成为一个“代”，垃圾收集的频率随着“代”的存活时间的增大而减小。也就是说，活得越长的对象。就越不可能是垃圾，就应该降低对它的垃圾收集频率。那么怎样来衡量这个存活时间：一般是利用几次垃圾收集动作来衡量，假设一个对象经过的垃圾收集次数越多，能够得出：该对象存活时间就越长。

分代回收是一种以空间换时间的操作方式，Python将内存根据对象的存活时间划分为不同的集合，每个集合称为一个代，Python将内存分为了3“代”，分别为年轻代（第0代）、中年代（第1代）、老年代（第2代），他们对应的是3个链表，它们的垃圾收集频率与对象的存活时间的增大而减小。新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python垃圾收集机制就会被触发，把那些可以被回收的对象回收掉，而那些不会回收的对象就会被移到中年代去，依此类推，老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。同时，分代回收是建立在标记清除技术基础之上。分代回收同样作为Python的辅助垃圾收集技术处理那些容器对象.象.
